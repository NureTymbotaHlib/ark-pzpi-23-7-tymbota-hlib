Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії



Звіт
з лабораторної роботи №4
з дисципліни «Аналіз та рефакторінг коду»
на тему: «Створення IоT клієнта»






Виконав:                                                                      Перевірив:
ст. гр. ПЗПІ 23-7                                                         Дашенков Д. С.
Тимбота Гліб Олексійович                                             
                                                                       






Харків 2025
     4.1 Мета роботи
     Отримати практичні навички з розробки IoT клієнта, включаючи проектування його архітектури, бізнес логіки, налаштувань, та інтеграцію із серверною частиною. Навчитися використовувати UML для створення діаграм прецедентів та діяльності, а також перевіряти функціональність IoT клієнта через тестування та інтеграцію.
     4.2 Хід роботи
     4.2.1 Проєктування архітектури IoT клієнта
     IoT-клієнт реалізується як симульований пристрій ESP32 у середовищі Wokwi, який періодично формує телеметричні дані транспортного засобу та передає їх на серверну частину через HTTP. Архітектура клієнта складається з модулів: (1) генерація/зчитування телеметрії (speed, координати, ознаки гальмування/удару), (2) керування підключенням Wi-Fi, (3) формування JSON-пакета, (4) HTTP-відправка на серверний endpoint /api/telemetry-events, (5) обробка помилок (повторні спроби) та логування у Serial Monitor. Обмін даними тестується через Swagger UI серверної частини, а підтвердження збереження подій виконується через базу даних MongoDB.
     4.2.2 Підготовка доступу IoT клієнта до серверу
     Серверну частину розгорнуто на платформі Render, у результаті чого отримано публічну адресу https://auto-insurance-server.onrender.com. Перевірку працездатності виконано через Swagger UI за шляхом /api/docs, що підтвердило доступність API для подальшої інтеграції з IoT-клієнтом.
     4.2.3 Підготовка Wokwi-проєкту
      У середовищі Wokwi створено проєкт на базі плати ESP32. Для моделювання вхідних даних використано потенціометр, який імітує зміну швидкості транспортного засобу, та кнопку для моделювання аварійної події (impact). Потенціометр підключено: VCC ? 3.3V, GND ? GND, SIG ? GPIO35 (ADC). Кнопку підключено: один контакт ? GPIO25, другий ? GND, з використанням внутрішньої підтяжки INPUT_PULLUP.

Рисунок 4.1 – Схема підключення елементів IoT-клієнта у Wokwi (ESP32, потенціометр, кнопка)
     4.2.4 Реалізація мережевої взаємодії із серверною частиною
     У IoT-клієнті реалізовано підключення до мережі Wi-Fi (SSID Wokwi-GUEST) та передавання телеметричних даних на серверну частину, розгорнуту на Render за адресою https://auto-insurance-server.onrender.com. Передавання здійснюється методом HTTP POST на endpoint /api/telemetry-events. Повідомлення формується у форматі JSON та відправляється із заголовком Content-Type: application/json. Результат запиту (HTTP-код та відповідь сервера) виводиться у Serial Monitor, що дозволяє підтвердити успішне прийняття події (код 201 Created) та отримати збережений об’єкт телеметричної події у відповіді.

Рисунок 4.2 – Результат HTTP POST телеметрії на сервер (HTTP 201, подію створено).
	4.2.5 Реалізація функцій налаштування IoT-клієнта
     У IoT-клієнті передбачено набір параметрів налаштування, які дозволяють адаптувати його до різних умов інтеграції без зміни основного алгоритму роботи. До таких параметрів належать адреса серверної частини для передавання телеметрії, ідентифікатор транспортного засобу, а також інтервал відправлення повідомлень. Окремо визначені параметри апаратного підключення елементів керування (вхід для зчитування швидкості та вхід для фіксації аварійної події). Завдяки цьому клієнт можна швидко переналаштувати під інший сервер, інший транспортний засіб або інший режим передавання даних, зберігаючи незмінною бізнес-логіку формування телеметрії.
     
     4.3 UML-діаграми IoT-клієнта
     4.3.1 UML діаграма прецедентів
     Діаграма прецедентів відображає взаємодію користувача з IoT-клієнтом у Wokwi та обмін даними із серверною частиною. Користувач ініціює налаштування параметрів клієнта і може імітувати аварійну подію кнопкою. IoT-клієнт формує телеметрію та надсилає її на сервер методом HTTP POST, а результат відображається у Serial Monitor.

Рисунок 4.3 – UML діаграма прецедентів IoT-клієнта (Wokwi/ESP32) та взаємодії з сервером.
     4.3.2 UML діаграма діяльності
     Діаграма діяльності описує алгоритм роботи IoT-клієнта: ініціалізація, підключення до Wi-Fi та циклічне формування телеметричного пакета. У кожному циклі клієнт зчитує значення швидкості та стан кнопки (impact), формує JSON і виконує HTTP POST на сервер. Результат запиту фіксується у Serial Monitor.

Рисунок 4.4 – UML діаграма діяльності IoT-клієнта при передачі телеметрії на сервер.

     4.4 Висновок
     У ході лабораторної роботи було розроблено IoT-клієнта у середовищі Wokwi на базі ESP32 для моделювання збору та передавання телеметричних даних транспортного засобу на серверну частину системи автострахування. Реалізовано формування телеметричного повідомлення у форматі JSON та його надсилання методом HTTP POST на endpoint /api/telemetry-events, а результати запитів відображалися у Serial Monitor. Передбачено параметри налаштування, які дають змогу адаптувати клієнт під інший сервер, транспортний засіб та інтервал передавання без зміни основного алгоритму. Для формалізації логіки роботи виконано UML-діаграму прецедентів і UML-діаграму діяльності.


ДОДАТОК А
Програмний код IoT клієнта
sketch.ino
#include <WiFi.h>
#include <HTTPClient.h>

const char* WIFI_SSID = "Wokwi-GUEST";
const char* WIFI_PASS = "";

const char* SERVER_URL =
  "https://auto-insurance-server.onrender.com/api/telemetry-events";

const int PIN_POT = 35;
const int PIN_BTN = 25;
const int VEHICLE_ID = 1;

const int SEND_INTERVAL_MS = 3000;

bool prevPressed = false;
unsigned long lastEdgeMs = 0;
const unsigned long BTN_DEBOUNCE_MS = 60;

bool crashed = false;                 
bool crashSnapshotPending = false;     
int crashSpeed = 0;                   

unsigned long lastSend = 0;

void connectWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) {
    delay(300);
    Serial.print(".");
  }
  Serial.println("\nWiFi connected");
}

int readSpeed() {
  int raw = analogRead(PIN_POT); // 0..4095
  int speed = map(raw, 0, 4095, 0, 120);
  if (speed < 0) speed = 0;
  if (speed > 200) speed = 200;
  return speed;
}

void updateCrashEvent() {
  bool pressed = (digitalRead(PIN_BTN) == LOW);
  unsigned long now = millis();

  if (pressed && !prevPressed) {
    if (now - lastEdgeMs >= BTN_DEBOUNCE_MS) {
      lastEdgeMs = now;

      if (!crashed) {
        crashSpeed = readSpeed();        
        crashed = true;                  
        crashSnapshotPending = true;     

        lastSend = 0;

        Serial.print("CRASH! speed=");
        Serial.println(crashSpeed);
      }
    }
  }

  prevPressed = pressed;
}

String buildJson(int speed, bool impact) {
  float lat = 49.9900;
  float lng = 36.2300;
  int rpm = 1500 + speed * 20;

  bool braking = speed < 10;

  String json = "{";
  json += "\"vehicle_id\":" + String(VEHICLE_ID) + ",";
  json += "\"timestamp\":\"" + String(millis()) + "\",";
  json += "\"speed\":" + String(speed) + ",";
  json += "\"engine_rpm\":" + String(rpm) + ",";
  json += "\"acceleration\":1.0,";
  json += "\"braking_flag\":" + String(braking ? "true" : "false") + ",";
  json += "\"impact_flag\":" + String(impact ? "true" : "false") + ",";
  json += "\"latitude\":" + String(lat, 6) + ",";
  json += "\"longitude\":" + String(lng, 6);
  json += "}";
  return json;
}

void postJson(const String& payload) {
  HTTPClient http;
  http.begin(SERVER_URL);
  http.addHeader("Content-Type", "application/json");

  int code = http.POST(payload);
  String resp = http.getString();

  Serial.println("---- TELEMETRY ----");
  Serial.println(payload);
  Serial.print("HTTP: ");
  Serial.println(code);
  Serial.println(resp);

  http.end();
}

void setup() {
  Serial.begin(115200);

  pinMode(PIN_BTN, INPUT_PULLUP);
  analogReadResolution(12);

  connectWiFi();

  Serial.print("Button pin state: ");
  Serial.println(digitalRead(PIN_BTN));
}

void loop() {
  if (WiFi.status() != WL_CONNECTED) connectWiFi();
  updateCrashEvent();

  unsigned long now = millis();

  if (crashSnapshotPending) {
    int speedToSend = crashSpeed;   
    bool impact = true;

    String json = buildJson(speedToSend, impact);
    postJson(json);

    crashSnapshotPending = false;
    lastSend = now;                
    delay(5);
    return;
  }

  if (now - lastSend >= (unsigned long)SEND_INTERVAL_MS) {
    lastSend = now;

    int speed = readSpeed();
    bool impact = crashed;

    if (crashed) {
      speed = 0;
    }

    String json = buildJson(speed, impact);
    postJson(json);
  }

  delay(5);
}

diagram.json
{
  "version": 1,
  "author": "Anonymous maker",
  "editor": "wokwi",
  "parts": [
    { "type": "board-esp32-devkit-c-v4", "id": "esp", "top": 0, "left": 0, "attrs": {} },
    {
      "type": "wokwi-pushbutton",
      "id": "btn1",
      "top": 92.6,
      "left": -115.2,
      "attrs": { "color": "green", "xray": "1" }
    },
    { "type": "wokwi-potentiometer", "id": "pot1", "top": -49.3, "left": -163.4, "attrs": {} }
  ],
  "connections": [
    [ "esp:TX", "$serialMonitor:RX", "", [] ],
    [ "esp:RX", "$serialMonitor:TX", "", [] ],
    [ "pot1:VCC", "esp:3V3", "red", [ "v0" ] ],
    [ "pot1:SIG", "esp:35", "green", [ "v0" ] ],
    [ "pot1:GND", "esp:GND.1", "black", [ "v0" ] ],
    [ "btn1:2.r", "esp:GND.1", "green", [ "h0" ] ],
    [ "btn1:1.r", "esp:25", "green", [ "v0" ] ]
  ],
  "dependencies": {}
}


ДОДАТОК Б
Посилання на відео: https://youtu.be/L4Qg17UrAfY
Посилання на гітхаб: https://github.com/NureTymbotaHlib/ark-pzpi-23-7-tymbota-hlib.git 

